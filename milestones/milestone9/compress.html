<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>compress API documentation</title>
<meta name="description" content="compress.py â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>compress</code></h1>
</header>
<section id="section-intro">
<p>compress.py</p>
<p>Buffered intercom with compression.</p>
<p>Compression class tries to reduce bitrate impact by compressing audio
chunk. The compression reduces de size of the payload sent over the
network.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    compress.py

    Buffered intercom with compression.

    Compression class tries to reduce bitrate impact by compressing audio
    chunk. The compression reduces de size of the payload sent over the
    network.
&#34;&#34;&#34;

# Used to compress and decompress using DEFLATE
import zlib

# Required to reuse Buffered intercom
import buffer
from buffer import minimal as mini

# Instead of importing from other modules
# its easier (but maybe not perfect) reimport
import struct
import numpy as np

try:
    import argcomplete  # &lt;tab&gt; completion for argparse.
except ImportError:
    print(&#34;Unable to import argcomplete&#34;)

# New parameters are generated to grant flexibility
mini.parser.add_argument(&#34;-cl&#34;, &#34;--compression_level&#34;, type=int, default=1, help=&#34;Compression level&#34;)
mini.parser.add_argument(&#34;-ndc&#34;, &#34;--dual_channel&#34;, type=int, default=1, help=&#34;Dual channel&#34;)

class Compression(buffer.Buffering):
    &#34;&#34;&#34;
    Class that implements a new buffered intercom with compression capabilities
    in order to reduce the bitrate effect.
    &#34;&#34;&#34;


    def __init__(self):
        &#34;&#34;&#34; Class constructor.

        The constructor class requires several arguments that must be provided before
        to get a compression instance. The constructor calls the constructor of Buffer class
        and also creates all variables needed, including the buffer array.
        &#34;&#34;&#34;
        super().__init__()
        if ((buffer.minimal.args.compression_level &lt; 0) or (buffer.minimal.args.compression_level &gt; 9)):
            mini.args.compression_level = 1

        self.compression_level = mini.args.compression_level
        &#34;&#34;&#34;(int) Level used by zlib to determinate compression.&#34;&#34;&#34;

        print(&#34;Compression level: &#34;, mini.args.compression_level)

        self.sender_chunk_buffer = np.zeros([buffer.minimal.args.frames_per_chunk * mini.Minimal.NUMBER_OF_CHANNELS], dtype=np.int16)
        &#34;&#34;&#34;(numpy array) Array used to store the arranged chunk before compression.&#34;&#34;&#34;

        self.receiver_chunk_buffer = np.zeros([buffer.minimal.args.frames_per_chunk, mini.Minimal.NUMBER_OF_CHANNELS], dtype = np.int16)
        &#34;&#34;&#34;(numpy array) Array used to store the arranged chunk after compression.&#34;&#34;&#34;

        self.sender_buf_size = len(self.sender_chunk_buffer)
        &#34;&#34;&#34;(int) Size of the sender_chunk_buffer.&#34;&#34;&#34;

        self.receiver_buf_size = len(self.receiver_chunk_buffer)
        &#34;&#34;&#34;(int) Size of the sender_chunk_buffer.&#34;&#34;&#34;

        self.channel_size = buffer.minimal.args.frames_per_chunk
        &#34;&#34;&#34;(int) Number of frames per chunk in each channel.&#34;&#34;&#34;


    def pack(self, chunk_number, chunk):
        &#34;&#34;&#34; Pack function (Override)

            Packs the chunk by joining the sequence number used by the buffer
            and the compressed output audio stream. To increase the compression
            rate, the output is arranged by joining the cells into the same
            channel in a consecutive array.

            Parameters
            ----------
                chunk_number
                    Sequence of the chunk to send.
                chunk
                    Audio output to send.
        &#34;&#34;&#34;

        # Join all frames ordering by channel
        if(buffer.minimal.args.dual_channel==1):
            self.sender_chunk_buffer[0: self.sender_buf_size // 2] = chunk[:, 0]
            self.sender_chunk_buffer[self.sender_buf_size // 2 : self.sender_buf_size] = chunk[:, 1]
        else:
            for i in range(0, mini.Minimal.NUMBER_OF_CHANNELS):
                self.sender_chunk_buffer[i * self.channel_size : (i + 1) * self.channel_size] = chunk[:, i]

        # Compress the arranged chunk
        packed_chunk = zlib.compress(self.sender_chunk_buffer, self.compression_level)

        # Join the sequence number and the arranged chunk
        packed_chunk = struct.pack(&#34;!H&#34;, chunk_number) + packed_chunk

        # Return the packed chunk
        return packed_chunk


    def unpack(self, packed_chunk, dtype=buffer.minimal.Minimal.SAMPLE_TYPE):
        &#34;&#34;&#34; Unpack function (Override)

            Unpack the chunk by extracting the sequence number and decompressing
            the compressed payload. The decompressed chunk must be rearranged
            to retrieve the original oudio.

            Parameters
            ----------
                packed_chunk
                    The payload extracted from the UDP socket.
                dtype
                    The type used in sounddevice stream. Used to rearrange the
                    retrieved chunk.
        &#34;&#34;&#34;
        # Extract the sequence number of the chunk
        (chunk_number,) = struct.unpack(&#34;!H&#34;, packed_chunk[:2])

        # Extract the compressed chunk
        unpacked_chunk = packed_chunk[2:]

        # Decompress the chunk
        unpacked_chunk = zlib.decompress(unpacked_chunk)

        # Convert to numpy array
        decompressed = np.frombuffer(unpacked_chunk, dtype=dtype)

        # Rearrange the chunk
        if(buffer.minimal.args.dual_channel):
            self.receiver_chunk_buffer[:, 0] = decompressed[0 : len(decompressed) // 2]
            self.receiver_chunk_buffer[:, 1] = decompressed[(len(decompressed) // 2): len(decompressed)]
        else:
            for i in range(0, mini.Minimal.NUMBER_OF_CHANNELS):
                self.receiver_chunk_buffer[:, i] = decompressed[i * self.channel_size: (i+1) * self.channel_size ]

        # Other way to rearrange the chunk by joining columns. Estimated to be less inefficient
        # than using numpy slices
        # chunk = np.column_stack((decompressed[0 : int(len(decompressed)/2)], decompressed[int(len(decompressed)/2)
        # : int(len(decompressed))]))

        # Return the sequence number an the original chunk
        return chunk_number, self.receiver_chunk_buffer


class Compression__verbose(Compression, buffer.Buffering__verbose):
    def __init__(self):
        super().__init__()

if __name__ == &#34;__main__&#34;:
    buffer.minimal.parser.description = __doc__
    try:
        argcomplete.autocomplete(buffer.minimal.parser)
    except Exception:
        if __debug__:
            print(&#34;argcomplete not working :-/&#34;)
        else:
            pass
    buffer.minimal.args = buffer.minimal.parser.parse_known_args()[0]
    if buffer.minimal.args.show_stats or buffer.minimal.args.show_samples:
        intercom = Compression__verbose()
    else:
        intercom = Compression()
    try:
        intercom.run()
    except KeyboardInterrupt:
        buffer.minimal.parser.exit(&#34;\nInterrupted by user&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="compress.Compression"><code class="flex name class">
<span>class <span class="ident">Compression</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that implements a new buffered intercom with compression capabilities
in order to reduce the bitrate effect.</p>
<p>Class constructor.</p>
<p>The constructor class requires several arguments that must be provided before
to get a compression instance. The constructor calls the constructor of Buffer class
and also creates all variables needed, including the buffer array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Compression(buffer.Buffering):
    &#34;&#34;&#34;
    Class that implements a new buffered intercom with compression capabilities
    in order to reduce the bitrate effect.
    &#34;&#34;&#34;


    def __init__(self):
        &#34;&#34;&#34; Class constructor.

        The constructor class requires several arguments that must be provided before
        to get a compression instance. The constructor calls the constructor of Buffer class
        and also creates all variables needed, including the buffer array.
        &#34;&#34;&#34;
        super().__init__()
        if ((buffer.minimal.args.compression_level &lt; 0) or (buffer.minimal.args.compression_level &gt; 9)):
            mini.args.compression_level = 1

        self.compression_level = mini.args.compression_level
        &#34;&#34;&#34;(int) Level used by zlib to determinate compression.&#34;&#34;&#34;

        print(&#34;Compression level: &#34;, mini.args.compression_level)

        self.sender_chunk_buffer = np.zeros([buffer.minimal.args.frames_per_chunk * mini.Minimal.NUMBER_OF_CHANNELS], dtype=np.int16)
        &#34;&#34;&#34;(numpy array) Array used to store the arranged chunk before compression.&#34;&#34;&#34;

        self.receiver_chunk_buffer = np.zeros([buffer.minimal.args.frames_per_chunk, mini.Minimal.NUMBER_OF_CHANNELS], dtype = np.int16)
        &#34;&#34;&#34;(numpy array) Array used to store the arranged chunk after compression.&#34;&#34;&#34;

        self.sender_buf_size = len(self.sender_chunk_buffer)
        &#34;&#34;&#34;(int) Size of the sender_chunk_buffer.&#34;&#34;&#34;

        self.receiver_buf_size = len(self.receiver_chunk_buffer)
        &#34;&#34;&#34;(int) Size of the sender_chunk_buffer.&#34;&#34;&#34;

        self.channel_size = buffer.minimal.args.frames_per_chunk
        &#34;&#34;&#34;(int) Number of frames per chunk in each channel.&#34;&#34;&#34;


    def pack(self, chunk_number, chunk):
        &#34;&#34;&#34; Pack function (Override)

            Packs the chunk by joining the sequence number used by the buffer
            and the compressed output audio stream. To increase the compression
            rate, the output is arranged by joining the cells into the same
            channel in a consecutive array.

            Parameters
            ----------
                chunk_number
                    Sequence of the chunk to send.
                chunk
                    Audio output to send.
        &#34;&#34;&#34;

        # Join all frames ordering by channel
        if(buffer.minimal.args.dual_channel==1):
            self.sender_chunk_buffer[0: self.sender_buf_size // 2] = chunk[:, 0]
            self.sender_chunk_buffer[self.sender_buf_size // 2 : self.sender_buf_size] = chunk[:, 1]
        else:
            for i in range(0, mini.Minimal.NUMBER_OF_CHANNELS):
                self.sender_chunk_buffer[i * self.channel_size : (i + 1) * self.channel_size] = chunk[:, i]

        # Compress the arranged chunk
        packed_chunk = zlib.compress(self.sender_chunk_buffer, self.compression_level)

        # Join the sequence number and the arranged chunk
        packed_chunk = struct.pack(&#34;!H&#34;, chunk_number) + packed_chunk

        # Return the packed chunk
        return packed_chunk


    def unpack(self, packed_chunk, dtype=buffer.minimal.Minimal.SAMPLE_TYPE):
        &#34;&#34;&#34; Unpack function (Override)

            Unpack the chunk by extracting the sequence number and decompressing
            the compressed payload. The decompressed chunk must be rearranged
            to retrieve the original oudio.

            Parameters
            ----------
                packed_chunk
                    The payload extracted from the UDP socket.
                dtype
                    The type used in sounddevice stream. Used to rearrange the
                    retrieved chunk.
        &#34;&#34;&#34;
        # Extract the sequence number of the chunk
        (chunk_number,) = struct.unpack(&#34;!H&#34;, packed_chunk[:2])

        # Extract the compressed chunk
        unpacked_chunk = packed_chunk[2:]

        # Decompress the chunk
        unpacked_chunk = zlib.decompress(unpacked_chunk)

        # Convert to numpy array
        decompressed = np.frombuffer(unpacked_chunk, dtype=dtype)

        # Rearrange the chunk
        if(buffer.minimal.args.dual_channel):
            self.receiver_chunk_buffer[:, 0] = decompressed[0 : len(decompressed) // 2]
            self.receiver_chunk_buffer[:, 1] = decompressed[(len(decompressed) // 2): len(decompressed)]
        else:
            for i in range(0, mini.Minimal.NUMBER_OF_CHANNELS):
                self.receiver_chunk_buffer[:, i] = decompressed[i * self.channel_size: (i+1) * self.channel_size ]

        # Other way to rearrange the chunk by joining columns. Estimated to be less inefficient
        # than using numpy slices
        # chunk = np.column_stack((decompressed[0 : int(len(decompressed)/2)], decompressed[int(len(decompressed)/2)
        # : int(len(decompressed))]))

        # Return the sequence number an the original chunk
        return chunk_number, self.receiver_chunk_buffer</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>buffer.Buffering</li>
<li>minimal.Minimal</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="compress.Compression__verbose" href="#compress.Compression__verbose">Compression__verbose</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="compress.Compression.channel_size"><code class="name">var <span class="ident">channel_size</span></code></dt>
<dd>
<div class="desc"><p>(int) Number of frames per chunk in each channel.</p></div>
</dd>
<dt id="compress.Compression.compression_level"><code class="name">var <span class="ident">compression_level</span></code></dt>
<dd>
<div class="desc"><p>(int) Level used by zlib to determinate compression.</p></div>
</dd>
<dt id="compress.Compression.receiver_buf_size"><code class="name">var <span class="ident">receiver_buf_size</span></code></dt>
<dd>
<div class="desc"><p>(int) Size of the sender_chunk_buffer.</p></div>
</dd>
<dt id="compress.Compression.receiver_chunk_buffer"><code class="name">var <span class="ident">receiver_chunk_buffer</span></code></dt>
<dd>
<div class="desc"><p>(numpy array) Array used to store the arranged chunk after compression.</p></div>
</dd>
<dt id="compress.Compression.sender_buf_size"><code class="name">var <span class="ident">sender_buf_size</span></code></dt>
<dd>
<div class="desc"><p>(int) Size of the sender_chunk_buffer.</p></div>
</dd>
<dt id="compress.Compression.sender_chunk_buffer"><code class="name">var <span class="ident">sender_chunk_buffer</span></code></dt>
<dd>
<div class="desc"><p>(numpy array) Array used to store the arranged chunk before compression.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="compress.Compression.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self, chunk_number, chunk)</span>
</code></dt>
<dd>
<div class="desc"><p>Pack function (Override)</p>
<p>Packs the chunk by joining the sequence number used by the buffer
and the compressed output audio stream. To increase the compression
rate, the output is arranged by joining the cells into the same
channel in a consecutive array.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>chunk_number
    Sequence of the chunk to send.
chunk
    Audio output to send.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(self, chunk_number, chunk):
    &#34;&#34;&#34; Pack function (Override)

        Packs the chunk by joining the sequence number used by the buffer
        and the compressed output audio stream. To increase the compression
        rate, the output is arranged by joining the cells into the same
        channel in a consecutive array.

        Parameters
        ----------
            chunk_number
                Sequence of the chunk to send.
            chunk
                Audio output to send.
    &#34;&#34;&#34;

    # Join all frames ordering by channel
    if(buffer.minimal.args.dual_channel==1):
        self.sender_chunk_buffer[0: self.sender_buf_size // 2] = chunk[:, 0]
        self.sender_chunk_buffer[self.sender_buf_size // 2 : self.sender_buf_size] = chunk[:, 1]
    else:
        for i in range(0, mini.Minimal.NUMBER_OF_CHANNELS):
            self.sender_chunk_buffer[i * self.channel_size : (i + 1) * self.channel_size] = chunk[:, i]

    # Compress the arranged chunk
    packed_chunk = zlib.compress(self.sender_chunk_buffer, self.compression_level)

    # Join the sequence number and the arranged chunk
    packed_chunk = struct.pack(&#34;!H&#34;, chunk_number) + packed_chunk

    # Return the packed chunk
    return packed_chunk</code></pre>
</details>
</dd>
<dt id="compress.Compression.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, packed_chunk, dtype=numpy.int16)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpack function (Override)</p>
<p>Unpack the chunk by extracting the sequence number and decompressing
the compressed payload. The decompressed chunk must be rearranged
to retrieve the original oudio.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>packed_chunk
    The payload extracted from the UDP socket.
dtype
    The type used in sounddevice stream. Used to rearrange the
    retrieved chunk.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack(self, packed_chunk, dtype=buffer.minimal.Minimal.SAMPLE_TYPE):
    &#34;&#34;&#34; Unpack function (Override)

        Unpack the chunk by extracting the sequence number and decompressing
        the compressed payload. The decompressed chunk must be rearranged
        to retrieve the original oudio.

        Parameters
        ----------
            packed_chunk
                The payload extracted from the UDP socket.
            dtype
                The type used in sounddevice stream. Used to rearrange the
                retrieved chunk.
    &#34;&#34;&#34;
    # Extract the sequence number of the chunk
    (chunk_number,) = struct.unpack(&#34;!H&#34;, packed_chunk[:2])

    # Extract the compressed chunk
    unpacked_chunk = packed_chunk[2:]

    # Decompress the chunk
    unpacked_chunk = zlib.decompress(unpacked_chunk)

    # Convert to numpy array
    decompressed = np.frombuffer(unpacked_chunk, dtype=dtype)

    # Rearrange the chunk
    if(buffer.minimal.args.dual_channel):
        self.receiver_chunk_buffer[:, 0] = decompressed[0 : len(decompressed) // 2]
        self.receiver_chunk_buffer[:, 1] = decompressed[(len(decompressed) // 2): len(decompressed)]
    else:
        for i in range(0, mini.Minimal.NUMBER_OF_CHANNELS):
            self.receiver_chunk_buffer[:, i] = decompressed[i * self.channel_size: (i+1) * self.channel_size ]

    # Other way to rearrange the chunk by joining columns. Estimated to be less inefficient
    # than using numpy slices
    # chunk = np.column_stack((decompressed[0 : int(len(decompressed)/2)], decompressed[int(len(decompressed)/2)
    # : int(len(decompressed))]))

    # Return the sequence number an the original chunk
    return chunk_number, self.receiver_chunk_buffer</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="compress.Compression__verbose"><code class="flex name class">
<span>class <span class="ident">Compression__verbose</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that implements a new buffered intercom with compression capabilities
in order to reduce the bitrate effect.</p>
<p>Class constructor.</p>
<p>The constructor class requires several arguments that must be provided before
to get a compression instance. The constructor calls the constructor of Buffer class
and also creates all variables needed, including the buffer array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Compression__verbose(Compression, buffer.Buffering__verbose):
    def __init__(self):
        super().__init__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="compress.Compression" href="#compress.Compression">Compression</a></li>
<li>buffer.Buffering__verbose</li>
<li>buffer.Buffering</li>
<li>minimal.Minimal__verbose</li>
<li>minimal.Minimal</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="compress.Compression" href="#compress.Compression">Compression</a></b></code>:
<ul class="hlist">
<li><code><a title="compress.Compression.channel_size" href="#compress.Compression.channel_size">channel_size</a></code></li>
<li><code><a title="compress.Compression.compression_level" href="#compress.Compression.compression_level">compression_level</a></code></li>
<li><code><a title="compress.Compression.pack" href="#compress.Compression.pack">pack</a></code></li>
<li><code><a title="compress.Compression.receiver_buf_size" href="#compress.Compression.receiver_buf_size">receiver_buf_size</a></code></li>
<li><code><a title="compress.Compression.receiver_chunk_buffer" href="#compress.Compression.receiver_chunk_buffer">receiver_chunk_buffer</a></code></li>
<li><code><a title="compress.Compression.sender_buf_size" href="#compress.Compression.sender_buf_size">sender_buf_size</a></code></li>
<li><code><a title="compress.Compression.sender_chunk_buffer" href="#compress.Compression.sender_chunk_buffer">sender_chunk_buffer</a></code></li>
<li><code><a title="compress.Compression.unpack" href="#compress.Compression.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="compress.Compression" href="#compress.Compression">Compression</a></code></h4>
<ul class="">
<li><code><a title="compress.Compression.channel_size" href="#compress.Compression.channel_size">channel_size</a></code></li>
<li><code><a title="compress.Compression.compression_level" href="#compress.Compression.compression_level">compression_level</a></code></li>
<li><code><a title="compress.Compression.pack" href="#compress.Compression.pack">pack</a></code></li>
<li><code><a title="compress.Compression.receiver_buf_size" href="#compress.Compression.receiver_buf_size">receiver_buf_size</a></code></li>
<li><code><a title="compress.Compression.receiver_chunk_buffer" href="#compress.Compression.receiver_chunk_buffer">receiver_chunk_buffer</a></code></li>
<li><code><a title="compress.Compression.sender_buf_size" href="#compress.Compression.sender_buf_size">sender_buf_size</a></code></li>
<li><code><a title="compress.Compression.sender_chunk_buffer" href="#compress.Compression.sender_chunk_buffer">sender_chunk_buffer</a></code></li>
<li><code><a title="compress.Compression.unpack" href="#compress.Compression.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="compress.Compression__verbose" href="#compress.Compression__verbose">Compression__verbose</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>