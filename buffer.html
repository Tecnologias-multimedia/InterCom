<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>buffer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buffer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Buffer
#
# The buffer class implements the mechanisms required to solve the jitter issues
# The ADT used is a circular queue that stores the packed received by the other
# interlocutor. The main purpose is to decrement the jitter effects by increasing
# the latency. In order to ensure that the queue has enough chunks to mitigate
# the jitter, the queue should be half filled. For that reason the initialisation
# waits to fill the half of the queue. A blank chunk with silence is played as
# a last resort in case to not have any chunk.


# import numpy as np
# Package to use several math functions
import math

# Package to performs conversions between Python values and C structs represented
# as Python strings
import struct

# Buffer is based by extending minimal class
from minimal import *
#import minimal

class Buffer(Minimal):
    &#34;&#34;&#34;
    Class that implements the buffer required to reduce the effect of the jitter.
    Inherits from Minimal used in Milestone 5
    &#34;&#34;&#34;

    MAX_CHUNK = 65536
    &#34;&#34;&#34;(int) (static): Max chunk size&#34;&#34;&#34;

    BUFFER_SIZE = 8
    &#34;&#34;&#34;(int) (static): Buffer size by default&#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Class constructor

        The constructor class requires several arguments that must be provided before
        to get an buffer instance. The constructor calls the constructor of Minimal class
        and also creates all variables needed, including the buffer array.
        &#34;&#34;&#34;

        super().__init__()

        self.jitter_time = args.jitter

        self.jitter_to_chunk_time = math.ceil(args.jitter / (self.chunk_time * 1000))
        &#34;&#34;&#34;(int) Result to convert jitter time to chunks size&#34;&#34;&#34;

        self.buffer_size = 2 * self.jitter_to_chunk_time
        &#34;&#34;&#34;(int) Size of the buffer. It is the double of jitter_to_chunk_time&#34;&#34;&#34;

        self.filled_cells = 0
        &#34;&#34;&#34;(int) Number of filled cells in the buffer&#34;&#34;&#34;

        self.index_local_cell = np.uint16(0)
        &#34;&#34;&#34;(int) Index of the current chunk&#34;&#34;&#34;

        self.index_remote_cell = np.uint16(0)
        &#34;&#34;&#34;(int) Index of the current chunk to send&#34;&#34;&#34;

        self.buffer_head = np.uint16(0)
        &#34;&#34;&#34;(int) Index of the head of the buffer&#34;&#34;&#34;

        # Print minimal information to visualize initialisation
        print(&#34;Chunk time: &#34;, self.chunk_time * 1000)
        print(&#34;Jitter time: &#34;, self.jitter_time)
        print(&#34;Jitter to chunk: &#34;, self.jitter_to_chunk_time)
        print(&#34;Tama√±o buffer: &#34;, self.buffer_size)

        self.current_cell = np.uint16(0)

        self.to_u16 = lambda x : np.uint16(x)
        &#34;&#34;&#34;(lambda) Lambda function to cast to 16 bits unsigned integer&#34;&#34;&#34;

        self.update_local_index = lambda: self.to_u16((self.index_local_cell + 1) % Buffer.MAX_CHUNK)
        &#34;&#34;&#34;(lambda) Lambda function to update (increase) the front of the queue&#34;&#34;&#34;

        self.update_remote_index = lambda: self.to_u16((self.index_remote_cell + 1) % Buffer.MAX_CHUNK)
        &#34;&#34;&#34;(lambda) Lambda function to update (increase) the rearof the queue&#34;&#34;&#34;

        self.index_package = lambda chunk_sequence: self.to_u16(chunk_sequence % self.buffer_size)
        &#34;&#34;&#34;(lambda) Lambda function to calculate the position of the package in the queue&#34;&#34;&#34;

        self.increment_cells = lambda cells: cells + 1
        &#34;&#34;&#34;(lambda) Lambda function to increment variable&#34;&#34;&#34;

        self.decrement_cells = lambda cells: cells - 1
        &#34;&#34;&#34;(lambda) Lambda function to decrement variable&#34;&#34;&#34;

        self.update_head = lambda : (self.buffer_head + 1) % self.buffer_size
        &#34;&#34;&#34;(lambda) Lambda function to update the head of the buffer&#34;&#34;&#34;

        self.pack_format = f&#34;H{args.frames_per_chunk * self.NUMBER_OF_CHANNELS}h&#34;
        &#34;&#34;&#34;(string) The format used in struct methods&#34;&#34;&#34;

        # Create fixed empty array
        self.buffer = [None] * self.buffer_size
        &#34;&#34;&#34;(list) A list that stores the buffer&#34;&#34;&#34;

        for i in range(len(self.buffer)):
            self.buffer[i] = self.zero_chunk

        self.half_buffer = False
        &#34;&#34;&#34;(Boolean) Controls the initial state of the buffer that requires to be half-filled&#34;&#34;&#34;

    # THIS IS THE CALLBACK
    def record_send_and_play(self, indata, outdata, frames, time, status):
        &#34;&#34;&#34; Callback function used by Sounddevice

        In non blocking audio stream, a new thread is created
        and periodically executes the callback method. Usually
        the call occurs when new input data (indata) is available to
        manipulate. Is recommended to manage output stream in the callback
        method also.

        The arguments are imposed to Sounndevice callback signature

        &#34;&#34;&#34;
        self.send(indata)
        self.play(outdata)

    def play(self, outdata):
        &#34;&#34;&#34; Places the next chunk of audio in output streams

            Calculates the position of next cell in buffer an retrieves it
            in order to assign to the outdata stream.
        Parameters
        ----------
            outdata
                Output stream used by Sounddevice
        &#34;&#34;&#34;
        if not self.half_buffer:
            to_play = self.zero_chunk
        else:
            #position = self.index_local_cell % self.buffer_size
            to_play = self.buffer[self.buffer_head]
            self.buffer[self.buffer_head] = self.zero_chunk
            self.filled_cells = self.filled_cells - 1
            self.buffer_head = self.update_head()
            #self.index_local_cell = self.update_local_index()
        outdata[:] = to_play

    # TODO EXECUTES IN MAIN THREAD
    def receive_and_buffer(self):
        &#34;&#34;&#34; Receive data from the socket and stores it in the buffer

            This method is executed in the main thread in a loop. It tries to retrieve
            data from the socket. If a packet is found in the buffer, the method
            extracts the sequence number and the payload. Converts the payload in a
            suitable numpy array an then stores it in the buffer uysing the sequence
            number provided.

            Raises
            ------
                socket.timeout
                    Resource temporarily unavailable. Socket may be empty.
                    In non-blocking UDP socket an exception of this type is raised.
        &#34;&#34;&#34;

        try:
            packed_data = self.receive()
            unpacked_data = struct.unpack(self.pack_format, packed_data)
            chunk_index = self.to_u16(unpacked_data[0])
            data = np.array(unpacked_data[1:])
            data = data.reshape(args.frames_per_chunk, self.NUMBER_OF_CHANNELS)
        except Exception as e:
            pass
        else :
            # print(&#34;Recibiendo: &#34;, chunk_index)
            self.buffer[chunk_index % self.buffer_size] = data
            self.filled_cells = self.filled_cells+1
            # print(&#34;Filled cells: &#34; , self.filled_cells)
        if (self.filled_cells &gt;= (len(self.buffer)/2)):
            self.half_buffer = True

    # TODO
    def start(self):
        self.sock.settimeout(0)
        &#34;&#34;&#34;Starts sounddevice audio stream via callback method&#34;&#34;&#34;
        with sd.Stream(samplerate=args.frames_per_second, blocksize=args.frames_per_chunk, dtype=self.SAMPLE_TYPE, channels=self.NUMBER_OF_CHANNELS, callback=self.record_send_and_play):
            while True:
                self.receive_and_buffer()

    def send(self, data):
        &#34;&#34;&#34; Send data over sender socket

            Uses parent&#39;s method to send data.

            Parameters
            ----------
                data
                    Data to send over UDP socket. A numpy array is expected
        &#34;&#34;&#34;
        chunk = struct.pack(self.pack_format, self.index_remote_cell, *(data.flatten()))
        # print(&#34;Enviando: &#34;, self.index_remote_cell)
        self.index_remote_cell = self.update_remote_index()
        super().send(chunk)

if __name__ == &#34;__main__&#34;:
    parser.description = __doc__
    try:
        argcomplete.autocomplete(parser)
    except Exception:
        print(&#34;argcomplete not working :-/&#34;)
    args = parser.parse_known_args()[0]

    if args.show_stats or args.show_samples:
        intercom = Buffer()
    else:
        intercom = Buffer()
    try:
        intercom.start()
    except KeyboardInterrupt:
        parser.exit(&#34;\nInterrupted by user&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="buffer.Buffer"><code class="flex name class">
<span>class <span class="ident">Buffer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that implements the buffer required to reduce the effect of the jitter.
Inherits from Minimal used in Milestone 5</p>
<p>Class constructor</p>
<p>The constructor class requires several arguments that must be provided before
to get an buffer instance. The constructor calls the constructor of Minimal class
and also creates all variables needed, including the buffer array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Buffer(Minimal):
    &#34;&#34;&#34;
    Class that implements the buffer required to reduce the effect of the jitter.
    Inherits from Minimal used in Milestone 5
    &#34;&#34;&#34;

    MAX_CHUNK = 65536
    &#34;&#34;&#34;(int) (static): Max chunk size&#34;&#34;&#34;

    BUFFER_SIZE = 8
    &#34;&#34;&#34;(int) (static): Buffer size by default&#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Class constructor

        The constructor class requires several arguments that must be provided before
        to get an buffer instance. The constructor calls the constructor of Minimal class
        and also creates all variables needed, including the buffer array.
        &#34;&#34;&#34;

        super().__init__()

        self.jitter_time = args.jitter

        self.jitter_to_chunk_time = math.ceil(args.jitter / (self.chunk_time * 1000))
        &#34;&#34;&#34;(int) Result to convert jitter time to chunks size&#34;&#34;&#34;

        self.buffer_size = 2 * self.jitter_to_chunk_time
        &#34;&#34;&#34;(int) Size of the buffer. It is the double of jitter_to_chunk_time&#34;&#34;&#34;

        self.filled_cells = 0
        &#34;&#34;&#34;(int) Number of filled cells in the buffer&#34;&#34;&#34;

        self.index_local_cell = np.uint16(0)
        &#34;&#34;&#34;(int) Index of the current chunk&#34;&#34;&#34;

        self.index_remote_cell = np.uint16(0)
        &#34;&#34;&#34;(int) Index of the current chunk to send&#34;&#34;&#34;

        self.buffer_head = np.uint16(0)
        &#34;&#34;&#34;(int) Index of the head of the buffer&#34;&#34;&#34;

        # Print minimal information to visualize initialisation
        print(&#34;Chunk time: &#34;, self.chunk_time * 1000)
        print(&#34;Jitter time: &#34;, self.jitter_time)
        print(&#34;Jitter to chunk: &#34;, self.jitter_to_chunk_time)
        print(&#34;Tama√±o buffer: &#34;, self.buffer_size)

        self.current_cell = np.uint16(0)

        self.to_u16 = lambda x : np.uint16(x)
        &#34;&#34;&#34;(lambda) Lambda function to cast to 16 bits unsigned integer&#34;&#34;&#34;

        self.update_local_index = lambda: self.to_u16((self.index_local_cell + 1) % Buffer.MAX_CHUNK)
        &#34;&#34;&#34;(lambda) Lambda function to update (increase) the front of the queue&#34;&#34;&#34;

        self.update_remote_index = lambda: self.to_u16((self.index_remote_cell + 1) % Buffer.MAX_CHUNK)
        &#34;&#34;&#34;(lambda) Lambda function to update (increase) the rearof the queue&#34;&#34;&#34;

        self.index_package = lambda chunk_sequence: self.to_u16(chunk_sequence % self.buffer_size)
        &#34;&#34;&#34;(lambda) Lambda function to calculate the position of the package in the queue&#34;&#34;&#34;

        self.increment_cells = lambda cells: cells + 1
        &#34;&#34;&#34;(lambda) Lambda function to increment variable&#34;&#34;&#34;

        self.decrement_cells = lambda cells: cells - 1
        &#34;&#34;&#34;(lambda) Lambda function to decrement variable&#34;&#34;&#34;

        self.update_head = lambda : (self.buffer_head + 1) % self.buffer_size
        &#34;&#34;&#34;(lambda) Lambda function to update the head of the buffer&#34;&#34;&#34;

        self.pack_format = f&#34;H{args.frames_per_chunk * self.NUMBER_OF_CHANNELS}h&#34;
        &#34;&#34;&#34;(string) The format used in struct methods&#34;&#34;&#34;

        # Create fixed empty array
        self.buffer = [None] * self.buffer_size
        &#34;&#34;&#34;(list) A list that stores the buffer&#34;&#34;&#34;

        for i in range(len(self.buffer)):
            self.buffer[i] = self.zero_chunk

        self.half_buffer = False
        &#34;&#34;&#34;(Boolean) Controls the initial state of the buffer that requires to be half-filled&#34;&#34;&#34;

    # THIS IS THE CALLBACK
    def record_send_and_play(self, indata, outdata, frames, time, status):
        &#34;&#34;&#34; Callback function used by Sounddevice

        In non blocking audio stream, a new thread is created
        and periodically executes the callback method. Usually
        the call occurs when new input data (indata) is available to
        manipulate. Is recommended to manage output stream in the callback
        method also.

        The arguments are imposed to Sounndevice callback signature

        &#34;&#34;&#34;
        self.send(indata)
        self.play(outdata)

    def play(self, outdata):
        &#34;&#34;&#34; Places the next chunk of audio in output streams

            Calculates the position of next cell in buffer an retrieves it
            in order to assign to the outdata stream.
        Parameters
        ----------
            outdata
                Output stream used by Sounddevice
        &#34;&#34;&#34;
        if not self.half_buffer:
            to_play = self.zero_chunk
        else:
            #position = self.index_local_cell % self.buffer_size
            to_play = self.buffer[self.buffer_head]
            self.buffer[self.buffer_head] = self.zero_chunk
            self.filled_cells = self.filled_cells - 1
            self.buffer_head = self.update_head()
            #self.index_local_cell = self.update_local_index()
        outdata[:] = to_play

    # TODO EXECUTES IN MAIN THREAD
    def receive_and_buffer(self):
        &#34;&#34;&#34; Receive data from the socket and stores it in the buffer

            This method is executed in the main thread in a loop. It tries to retrieve
            data from the socket. If a packet is found in the buffer, the method
            extracts the sequence number and the payload. Converts the payload in a
            suitable numpy array an then stores it in the buffer uysing the sequence
            number provided.

            Raises
            ------
                socket.timeout
                    Resource temporarily unavailable. Socket may be empty.
                    In non-blocking UDP socket an exception of this type is raised.
        &#34;&#34;&#34;

        try:
            packed_data = self.receive()
            unpacked_data = struct.unpack(self.pack_format, packed_data)
            chunk_index = self.to_u16(unpacked_data[0])
            data = np.array(unpacked_data[1:])
            data = data.reshape(args.frames_per_chunk, self.NUMBER_OF_CHANNELS)
        except Exception as e:
            pass
        else :
            # print(&#34;Recibiendo: &#34;, chunk_index)
            self.buffer[chunk_index % self.buffer_size] = data
            self.filled_cells = self.filled_cells+1
            # print(&#34;Filled cells: &#34; , self.filled_cells)
        if (self.filled_cells &gt;= (len(self.buffer)/2)):
            self.half_buffer = True

    # TODO
    def start(self):
        self.sock.settimeout(0)
        &#34;&#34;&#34;Starts sounddevice audio stream via callback method&#34;&#34;&#34;
        with sd.Stream(samplerate=args.frames_per_second, blocksize=args.frames_per_chunk, dtype=self.SAMPLE_TYPE, channels=self.NUMBER_OF_CHANNELS, callback=self.record_send_and_play):
            while True:
                self.receive_and_buffer()

    def send(self, data):
        &#34;&#34;&#34; Send data over sender socket

            Uses parent&#39;s method to send data.

            Parameters
            ----------
                data
                    Data to send over UDP socket. A numpy array is expected
        &#34;&#34;&#34;
        chunk = struct.pack(self.pack_format, self.index_remote_cell, *(data.flatten()))
        # print(&#34;Enviando: &#34;, self.index_remote_cell)
        self.index_remote_cell = self.update_remote_index()
        super().send(chunk)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>minimal.Minimal</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="buffer.Buffer.BUFFER_SIZE"><code class="name">var <span class="ident">BUFFER_SIZE</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Buffer size by default</p></div>
</dd>
<dt id="buffer.Buffer.MAX_CHUNK"><code class="name">var <span class="ident">MAX_CHUNK</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Max chunk size</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="buffer.Buffer.buffer"><code class="name">var <span class="ident">buffer</span></code></dt>
<dd>
<div class="desc"><p>(list) A list that stores the buffer</p></div>
</dd>
<dt id="buffer.Buffer.buffer_head"><code class="name">var <span class="ident">buffer_head</span></code></dt>
<dd>
<div class="desc"><p>(int) Index of the head of the buffer</p></div>
</dd>
<dt id="buffer.Buffer.buffer_size"><code class="name">var <span class="ident">buffer_size</span></code></dt>
<dd>
<div class="desc"><p>(int) Size of the buffer. It is the double of jitter_to_chunk_time</p></div>
</dd>
<dt id="buffer.Buffer.decrement_cells"><code class="name">var <span class="ident">decrement_cells</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to decrement variable</p></div>
</dd>
<dt id="buffer.Buffer.filled_cells"><code class="name">var <span class="ident">filled_cells</span></code></dt>
<dd>
<div class="desc"><p>(int) Number of filled cells in the buffer</p></div>
</dd>
<dt id="buffer.Buffer.half_buffer"><code class="name">var <span class="ident">half_buffer</span></code></dt>
<dd>
<div class="desc"><p>(Boolean) Controls the initial state of the buffer that requires to be half-filled</p></div>
</dd>
<dt id="buffer.Buffer.increment_cells"><code class="name">var <span class="ident">increment_cells</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to increment variable</p></div>
</dd>
<dt id="buffer.Buffer.index_local_cell"><code class="name">var <span class="ident">index_local_cell</span></code></dt>
<dd>
<div class="desc"><p>(int) Index of the current chunk</p></div>
</dd>
<dt id="buffer.Buffer.index_package"><code class="name">var <span class="ident">index_package</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to calculate the position of the package in the queue</p></div>
</dd>
<dt id="buffer.Buffer.index_remote_cell"><code class="name">var <span class="ident">index_remote_cell</span></code></dt>
<dd>
<div class="desc"><p>(int) Index of the current chunk to send</p></div>
</dd>
<dt id="buffer.Buffer.jitter_to_chunk_time"><code class="name">var <span class="ident">jitter_to_chunk_time</span></code></dt>
<dd>
<div class="desc"><p>(int) Result to convert jitter time to chunks size</p></div>
</dd>
<dt id="buffer.Buffer.pack_format"><code class="name">var <span class="ident">pack_format</span></code></dt>
<dd>
<div class="desc"><p>(string) The format used in struct methods</p></div>
</dd>
<dt id="buffer.Buffer.to_u16"><code class="name">var <span class="ident">to_u16</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to cast to 16 bits unsigned integer</p></div>
</dd>
<dt id="buffer.Buffer.update_head"><code class="name">var <span class="ident">update_head</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to update the head of the buffer</p></div>
</dd>
<dt id="buffer.Buffer.update_local_index"><code class="name">var <span class="ident">update_local_index</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to update (increase) the front of the queue</p></div>
</dd>
<dt id="buffer.Buffer.update_remote_index"><code class="name">var <span class="ident">update_remote_index</span></code></dt>
<dd>
<div class="desc"><p>(lambda) Lambda function to update (increase) the rearof the queue</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="buffer.Buffer.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, outdata)</span>
</code></dt>
<dd>
<div class="desc"><p>Places the next chunk of audio in output streams</p>
<pre><code>Calculates the position of next cell in buffer an retrieves it
in order to assign to the outdata stream.
</code></pre>
<h2 id="parameters">Parameters</h2>
<pre><code>outdata
    Output stream used by Sounddevice
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, outdata):
    &#34;&#34;&#34; Places the next chunk of audio in output streams

        Calculates the position of next cell in buffer an retrieves it
        in order to assign to the outdata stream.
    Parameters
    ----------
        outdata
            Output stream used by Sounddevice
    &#34;&#34;&#34;
    if not self.half_buffer:
        to_play = self.zero_chunk
    else:
        #position = self.index_local_cell % self.buffer_size
        to_play = self.buffer[self.buffer_head]
        self.buffer[self.buffer_head] = self.zero_chunk
        self.filled_cells = self.filled_cells - 1
        self.buffer_head = self.update_head()
        #self.index_local_cell = self.update_local_index()
    outdata[:] = to_play</code></pre>
</details>
</dd>
<dt id="buffer.Buffer.receive_and_buffer"><code class="name flex">
<span>def <span class="ident">receive_and_buffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive data from the socket and stores it in the buffer</p>
<p>This method is executed in the main thread in a loop. It tries to retrieve
data from the socket. If a packet is found in the buffer, the method
extracts the sequence number and the payload. Converts the payload in a
suitable numpy array an then stores it in the buffer uysing the sequence
number provided.</p>
<h2 id="raises">Raises</h2>
<pre><code>socket.timeout
    Resource temporarily unavailable. Socket may be empty.
    In non-blocking UDP socket an exception of this type is raised.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive_and_buffer(self):
    &#34;&#34;&#34; Receive data from the socket and stores it in the buffer

        This method is executed in the main thread in a loop. It tries to retrieve
        data from the socket. If a packet is found in the buffer, the method
        extracts the sequence number and the payload. Converts the payload in a
        suitable numpy array an then stores it in the buffer uysing the sequence
        number provided.

        Raises
        ------
            socket.timeout
                Resource temporarily unavailable. Socket may be empty.
                In non-blocking UDP socket an exception of this type is raised.
    &#34;&#34;&#34;

    try:
        packed_data = self.receive()
        unpacked_data = struct.unpack(self.pack_format, packed_data)
        chunk_index = self.to_u16(unpacked_data[0])
        data = np.array(unpacked_data[1:])
        data = data.reshape(args.frames_per_chunk, self.NUMBER_OF_CHANNELS)
    except Exception as e:
        pass
    else :
        # print(&#34;Recibiendo: &#34;, chunk_index)
        self.buffer[chunk_index % self.buffer_size] = data
        self.filled_cells = self.filled_cells+1
        # print(&#34;Filled cells: &#34; , self.filled_cells)
    if (self.filled_cells &gt;= (len(self.buffer)/2)):
        self.half_buffer = True</code></pre>
</details>
</dd>
<dt id="buffer.Buffer.record_send_and_play"><code class="name flex">
<span>def <span class="ident">record_send_and_play</span></span>(<span>self, indata, outdata, frames, time, status)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function used by Sounddevice</p>
<p>In non blocking audio stream, a new thread is created
and periodically executes the callback method. Usually
the call occurs when new input data (indata) is available to
manipulate. Is recommended to manage output stream in the callback
method also.</p>
<p>The arguments are imposed to Sounndevice callback signature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record_send_and_play(self, indata, outdata, frames, time, status):
    &#34;&#34;&#34; Callback function used by Sounddevice

    In non blocking audio stream, a new thread is created
    and periodically executes the callback method. Usually
    the call occurs when new input data (indata) is available to
    manipulate. Is recommended to manage output stream in the callback
    method also.

    The arguments are imposed to Sounndevice callback signature

    &#34;&#34;&#34;
    self.send(indata)
    self.play(outdata)</code></pre>
</details>
</dd>
<dt id="buffer.Buffer.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data over sender socket</p>
<p>Uses parent's method to send data.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>data
    Data to send over UDP socket. A numpy array is expected
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, data):
    &#34;&#34;&#34; Send data over sender socket

        Uses parent&#39;s method to send data.

        Parameters
        ----------
            data
                Data to send over UDP socket. A numpy array is expected
    &#34;&#34;&#34;
    chunk = struct.pack(self.pack_format, self.index_remote_cell, *(data.flatten()))
    # print(&#34;Enviando: &#34;, self.index_remote_cell)
    self.index_remote_cell = self.update_remote_index()
    super().send(chunk)</code></pre>
</details>
</dd>
<dt id="buffer.Buffer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    self.sock.settimeout(0)
    &#34;&#34;&#34;Starts sounddevice audio stream via callback method&#34;&#34;&#34;
    with sd.Stream(samplerate=args.frames_per_second, blocksize=args.frames_per_chunk, dtype=self.SAMPLE_TYPE, channels=self.NUMBER_OF_CHANNELS, callback=self.record_send_and_play):
        while True:
            self.receive_and_buffer()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="buffer.Buffer" href="#buffer.Buffer">Buffer</a></code></h4>
<ul class="">
<li><code><a title="buffer.Buffer.BUFFER_SIZE" href="#buffer.Buffer.BUFFER_SIZE">BUFFER_SIZE</a></code></li>
<li><code><a title="buffer.Buffer.MAX_CHUNK" href="#buffer.Buffer.MAX_CHUNK">MAX_CHUNK</a></code></li>
<li><code><a title="buffer.Buffer.buffer" href="#buffer.Buffer.buffer">buffer</a></code></li>
<li><code><a title="buffer.Buffer.buffer_head" href="#buffer.Buffer.buffer_head">buffer_head</a></code></li>
<li><code><a title="buffer.Buffer.buffer_size" href="#buffer.Buffer.buffer_size">buffer_size</a></code></li>
<li><code><a title="buffer.Buffer.decrement_cells" href="#buffer.Buffer.decrement_cells">decrement_cells</a></code></li>
<li><code><a title="buffer.Buffer.filled_cells" href="#buffer.Buffer.filled_cells">filled_cells</a></code></li>
<li><code><a title="buffer.Buffer.half_buffer" href="#buffer.Buffer.half_buffer">half_buffer</a></code></li>
<li><code><a title="buffer.Buffer.increment_cells" href="#buffer.Buffer.increment_cells">increment_cells</a></code></li>
<li><code><a title="buffer.Buffer.index_local_cell" href="#buffer.Buffer.index_local_cell">index_local_cell</a></code></li>
<li><code><a title="buffer.Buffer.index_package" href="#buffer.Buffer.index_package">index_package</a></code></li>
<li><code><a title="buffer.Buffer.index_remote_cell" href="#buffer.Buffer.index_remote_cell">index_remote_cell</a></code></li>
<li><code><a title="buffer.Buffer.jitter_to_chunk_time" href="#buffer.Buffer.jitter_to_chunk_time">jitter_to_chunk_time</a></code></li>
<li><code><a title="buffer.Buffer.pack_format" href="#buffer.Buffer.pack_format">pack_format</a></code></li>
<li><code><a title="buffer.Buffer.play" href="#buffer.Buffer.play">play</a></code></li>
<li><code><a title="buffer.Buffer.receive_and_buffer" href="#buffer.Buffer.receive_and_buffer">receive_and_buffer</a></code></li>
<li><code><a title="buffer.Buffer.record_send_and_play" href="#buffer.Buffer.record_send_and_play">record_send_and_play</a></code></li>
<li><code><a title="buffer.Buffer.send" href="#buffer.Buffer.send">send</a></code></li>
<li><code><a title="buffer.Buffer.start" href="#buffer.Buffer.start">start</a></code></li>
<li><code><a title="buffer.Buffer.to_u16" href="#buffer.Buffer.to_u16">to_u16</a></code></li>
<li><code><a title="buffer.Buffer.update_head" href="#buffer.Buffer.update_head">update_head</a></code></li>
<li><code><a title="buffer.Buffer.update_local_index" href="#buffer.Buffer.update_local_index">update_local_index</a></code></li>
<li><code><a title="buffer.Buffer.update_remote_index" href="#buffer.Buffer.update_remote_index">update_remote_index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>