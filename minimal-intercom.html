<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>minimal-intercom API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>minimal-intercom</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Minimal Intercom
#
# A very simple inercomunicator based in Intercom_minimal.py and wire.py
# programs that sends chunk audio in blocks between two (or one) networked
# processes, based in peer to peer p2p architecture. Both parts are sender
# and receiver simultaneously
#
# The callback method based system (with numpy arrays) will be used to
# record and play audio. In order to control lantency issues, fixed chunks
# will be used. The chunks of audio recorder are send using a UDP socket.
# The receiver will have all chunk received stored in the socket queue instead
# of using an explicit queue object. It means the callback method has to
# send the current recorded chunk and withdraw an element of the socket queue.
# There is no control of the receiver socket queue.

# Package to handle command-line arguments
import argparse

# Package to use socket API for network communication
import socket

# Package that provides bindings for PortAudio library
# that allows usage of numpy arrays.
try:
    import sounddevice as sd
except ModuleNotFoundError:
    import os
    os.system(&#34;pip3 install sounddevice --user&#34;)
    import sounddevice as sd

# Package that provides efficient arrays.
try:
    import numpy as np
except ModuleNotFoundError:
    print(&#34;Installing numpy with pip&#34;)
    import os
    os.system(&#34;pip3 install numpy --user&#34;)
    import numpy as np

# Package to process and system monitoring
try:
    import psutil
except ModuleNotFoundError:
    import os
    os.system(&#34;pip3 install psutil --user&#34;)
    import psutil

# Accumulated CPU usage
CPU_total = 0

# Number of samples of CPU
CPU_samples = 0

# MinimalIntercom class

class MinimalIntercom:
    &#34;&#34;&#34;
    Class to wrap Minimal Intercom functionalities and data


    &#34;&#34;&#34;

    NUMBER_CHANNELS = 1
    &#34;&#34;&#34;(int) (static): Number of channels by default&#34;&#34;&#34;

    SAMPLE_RATE = 44100
    &#34;&#34;&#34;(int) (static): Sampling frequency. Number of frames per second&#34;&#34;&#34;

    CHUNK_SIZE = 512
    &#34;&#34;&#34;(int) (static): Size of sampling chunk. A chunk is composed
    by frames&#34;&#34;&#34;


    SOURCE_PORT = 7676
    &#34;&#34;&#34;(int) (static): Port used to receive data from network&#34;&#34;&#34;

    DESTINATION_PORT = 7676
    &#34;&#34;&#34;(int) (static): Port used to send data to networks&#34;&#34;&#34;

    DESTINATION_ADDRESS = &#34;localhost&#34; # &#34;192.168.1.37&#34;
    &#34;&#34;&#34;(string) (static): IP address of destination computer&#34;&#34;&#34;


    MAX_PAYLOAD_BYTES = 32768
    &#34;&#34;&#34;(int) (static): Maximum size of UDP payload&#34;&#34;&#34;

    def __init__(self, args):
        &#34;&#34;&#34;
        Class constructor

        The constructor class requires several arguments that must be provided before
        to get an intercom instance. The constructor also creates the sockets required
        to send and receive data. In order to acquire the arguments correctly, there
        is an static method called add_args.
        &#34;&#34;&#34;

        # Elemental instance variables initialized by arguments

        self.number_of_channels = args.number_of_channels
        &#34;&#34;&#34;number_of_channels (int): Number of channels&#34;&#34;&#34;

        self.sample_rate = args.frames_per_second
        &#34;&#34;&#34;Sampling frequency. Number of frames per second&#34;&#34;&#34;

        self.chunk_size = args.frames_per_chunk
        &#34;&#34;&#34;Size of sampling chunk.&#34;&#34;&#34;

        self.source_port = args.source_port
        &#34;&#34;&#34;Port used to listen incoming data&#34;&#34;&#34;

        self.destination_address = args.destination_address
        &#34;&#34;&#34;IP address used to send data&#34;&#34;&#34;

        self.destination_port = args.destination_port
        &#34;&#34;&#34;Port used to send data&#34;&#34;&#34;

        self.sample_type = np.int16
        &#34;&#34;&#34;Typo of sample. Used for data definition and size calculation&#34;&#34;&#34;

        self.samples_per_chunk = self.chunk_size * self.number_of_channels
        &#34;&#34;&#34;Number of audio samples required per chunk.&#34;&#34;&#34;

        self.bytes_per_chunk = self.samples_per_chunk * np.dtype(self.sample_type).itemsize
        &#34;&#34;&#34;Size of audio chunk in bytes.&#34;&#34;&#34;

        # Assertion is activated if number of bytes per chunk is less than maximum payload size
        # This action is used to ensure reliable UDP communication
        assert self.bytes_per_chunk &lt;= MinimalIntercom.MAX_PAYLOAD_BYTES, \
        f&#34;bytes_per_chunk={self.bytes_per_chunk} &gt; MAX_PAYLOAD_BYTES={MinimalIntercom.MAX_PAYLOAD_BYTES}h&#34;

        # Endpoints pair declaration
        self.sender_endpoint = (self.destination_address, self.destination_port)
        &#34;&#34;&#34;Sender endpoint. Fixed to destination IP address and port&#34;&#34;&#34;

        self.receiver_endpoint = (&#34;0.0.0.0&#34;, self.source_port)
        &#34;&#34;&#34;Receiver endpoint. Fixed to any IP address and port used for listening&#34;&#34;&#34;

        # Socket initialization
        self.sender_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
        &#34;&#34;&#34;Sender socket. Used to send data.&#34;&#34;&#34;

        self.receiver_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
        &#34;&#34;&#34;Receiver socket. Binded to receiver endpoint. By default is set to 
        non blocking mode&#34;&#34;&#34;

        # Set receiver socket in non bloking
        self.receiver_socket.setblocking(0)
        self.receiver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 30000)

        # Bind listener socket
        self.receiver_socket.bind(self.receiver_endpoint)

        # Auxiliary chunk filled width zeros
        self.zero_chunk = self.generate_zero_chunk()

        # Data received via socket. Initialized with zero values
        self.data = self.generate_zero_chunk()
        &#34;&#34;&#34;Numpy array to store data received &#34;&#34;&#34;

    # Destructor of class
    def __del__(self):
        &#34;&#34;&#34; Destructor of class. Just closes socket before to destroy it &#34;&#34;&#34;
        self.receiver_socket.close()

    def to_print(self):
        &#34;&#34;&#34;To print instance main variables. Used to know current instance&#39;s status&#34;&#34;&#34;

        print(f&#34;Minimal intercom: number_of_channels={self.number_of_channels}&#34;)
        print(f&#34;Minimal intercom: sample rate={self.sample_rate}&#34;)
        print(f&#34;Minimal intercom: chunk_size={self.chunk_size}&#34;)
        print(f&#34;Minimal intercom: samples_per_chunk={self.samples_per_chunk}&#34;)
        print(f&#34;Minimal intercom: source port={self.source_port}&#34;)
        print(f&#34;Minimal intercom: destination_address={self.destination_address}&#34;)
        print(f&#34;Minimal intercom: destination_port={self.destination_port}&#34;)
        print(f&#34;Minimal intercom: bytes_per_chunk={self.bytes_per_chunk}&#34;)

    # Zero chunk generator
    def generate_zero_chunk(self):
        &#34;&#34;&#34; Generator of numpy chunk filled with zeros

        Returns
        ------
            numpy array filled with zeros
        &#34;&#34;&#34;
        return np.zeros((self.chunk_size, self.number_of_channels), self.sample_type)

    def send(self, data):
        &#34;&#34;&#34; Send data over sender socket

        Parameters
        ----------
        data
            Data to send over UDP socket. A numpy array is expected
        &#34;&#34;&#34;
        self.sender_socket.sendto(data, self.sender_endpoint)  #self.sender_endpoint)

    def receive(self):
        &#34;&#34;&#34;Receive data from receiver socket

        Raises
        ------
            Errno 11
                Resource temporarily unavailable. Socket may be empty.
                In non-blocking UDP socket an exception of this type is raised.

        Returns
        -------
            Numpy array of FIFO socket buffer
        &#34;&#34;&#34;

        # Data is required from socket. However, socket may have no data, so to handle
        # this situation, try-catch block is required
        try:
            # Store received data in local variable
            data, status = self.receiver_socket.recvfrom(self.bytes_per_chunk)

            # Due to data is byte object, conversion to numpy array is required
            data = np.frombuffer(data, self.sample_type).reshape(self.chunk_size, self.number_of_channels)
        except Exception as e:
            print(&#34;Exception: &#34;, e)
            # Id there is no data in socket, get zero filled chunk
            data = self.generate_zero_chunk()

        # Return data
        return data

    def feedback(self):
        &#34;&#34;&#34;Calculates process parameters&#34;&#34;&#34;
        global CPU_total
        global CPU_samples
        CPU_usage = psutil.cpu_percent()  # User (not intercom) time
        CPU_total += CPU_usage
        CPU_samples += 1
        print(f&#34;{int(CPU_usage)}&#34;, flush=True, end=&#39; &#39;)

    # Callback method required from non blocking Sounddevice audio stream
    def callback(self, indata, outdata, frames, time, status):
        &#34;&#34;&#34;Callback method

        In non blocking audio stream, a new thread is created
        and periodically executes the callback method. Usually
        the call occurs when new input data (indata) is available to
        manipulate. Is recommended to manage output stream in the callback
        method also

        Note: This method has the implementation of the algorithm
        proposed in milestone 5 in Multimedia Technology subject

        The arguments are imposed to Sounndevice callback signature
        &#34;&#34;&#34;

        # Send data via sender socket
        self.send(indata)

        # Receive and store data to play
        outdata[:] = self.receive()

        # Print current process status
        self.feedback()

    def start(self):
        &#34;&#34;&#34;Starts sounddevice audio stream via callbacks method&#34;&#34;&#34;
        with sd.Stream(samplerate=self.sample_rate, blocksize=self.chunk_size, dtype=self.sample_type,
                       channels=self.number_of_channels, callback=self.callback):
            input()

    @staticmethod
    def add_args():
        &#34;&#34;&#34;Allows to parse command line arguments. Default values (class attributes)
            are used by any parameter not provided

            Returns
            -------
                Parser structure with parameters to initialize MinimalIntercom instance
        &#34;&#34;&#34;
        parser = argparse.ArgumentParser(description = &#34;Real-Time Audio Intercommunicator&#34;,
                                        formatter_class = argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument(&#34;-s&#34;, &#34;--frames_per_chunk&#34;,
                            help=&#34;Number of frames (stereo samples) per chunk.&#34;,
                            type=int, default=MinimalIntercom.CHUNK_SIZE)
        parser.add_argument(&#34;-r&#34;, &#34;--frames_per_second&#34;,
                            help=&#34;Sampling rate in frames/second.&#34;,
                            type=int, default=MinimalIntercom.SAMPLE_RATE)
        parser.add_argument(&#34;-c&#34;, &#34;--number_of_channels&#34;,
                            help=&#34;Number of channels.&#34;,
                            type=int, default=MinimalIntercom.NUMBER_CHANNELS)
        parser.add_argument(&#34;-p&#34;, &#34;--source_port&#34;,
                            help=&#34;My listening port.&#34;,
                            type=int, default=MinimalIntercom.SOURCE_PORT)
        parser.add_argument(&#34;-i&#34;, &#34;--destination_port&#34;,
                            help=&#34;Interlocutor&#39;s listening port.&#34;,
                            type=int, default=MinimalIntercom.DESTINATION_PORT)
        parser.add_argument(&#34;-a&#34;, &#34;--destination_address&#34;,
                            help=&#34;Interlocutor&#39;s IP address or name.&#34;,
                            type=str, default=MinimalIntercom.DESTINATION_ADDRESS)
        return parser

# MAIN
if __name__ == &#34;__main__&#34;:
    parser_arguments = MinimalIntercom.add_args()
    args = parser_arguments.parse_args()
    # print(args)
    intercom = MinimalIntercom(args)
    intercom.to_print()
    try:
        intercom.start()
    except KeyboardInterrupt:
        parser_arguments.exit(1,&#34;\n Interrupted by user&#34;)
    except Exception as e:
        parser_arguments.exit(1, type(e).__name__ + &#39;: &#39; + str(e))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="minimal-intercom.MinimalIntercom"><code class="flex name class">
<span>class <span class="ident">MinimalIntercom</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to wrap Minimal Intercom functionalities and data</p>
<p>Class constructor</p>
<p>The constructor class requires several arguments that must be provided before
to get an intercom instance. The constructor also creates the sockets required
to send and receive data. In order to acquire the arguments correctly, there
is an static method called add_args.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MinimalIntercom:
    &#34;&#34;&#34;
    Class to wrap Minimal Intercom functionalities and data


    &#34;&#34;&#34;

    NUMBER_CHANNELS = 1
    &#34;&#34;&#34;(int) (static): Number of channels by default&#34;&#34;&#34;

    SAMPLE_RATE = 44100
    &#34;&#34;&#34;(int) (static): Sampling frequency. Number of frames per second&#34;&#34;&#34;

    CHUNK_SIZE = 512
    &#34;&#34;&#34;(int) (static): Size of sampling chunk. A chunk is composed
    by frames&#34;&#34;&#34;


    SOURCE_PORT = 7676
    &#34;&#34;&#34;(int) (static): Port used to receive data from network&#34;&#34;&#34;

    DESTINATION_PORT = 7676
    &#34;&#34;&#34;(int) (static): Port used to send data to networks&#34;&#34;&#34;

    DESTINATION_ADDRESS = &#34;localhost&#34; # &#34;192.168.1.37&#34;
    &#34;&#34;&#34;(string) (static): IP address of destination computer&#34;&#34;&#34;


    MAX_PAYLOAD_BYTES = 32768
    &#34;&#34;&#34;(int) (static): Maximum size of UDP payload&#34;&#34;&#34;

    def __init__(self, args):
        &#34;&#34;&#34;
        Class constructor

        The constructor class requires several arguments that must be provided before
        to get an intercom instance. The constructor also creates the sockets required
        to send and receive data. In order to acquire the arguments correctly, there
        is an static method called add_args.
        &#34;&#34;&#34;

        # Elemental instance variables initialized by arguments

        self.number_of_channels = args.number_of_channels
        &#34;&#34;&#34;number_of_channels (int): Number of channels&#34;&#34;&#34;

        self.sample_rate = args.frames_per_second
        &#34;&#34;&#34;Sampling frequency. Number of frames per second&#34;&#34;&#34;

        self.chunk_size = args.frames_per_chunk
        &#34;&#34;&#34;Size of sampling chunk.&#34;&#34;&#34;

        self.source_port = args.source_port
        &#34;&#34;&#34;Port used to listen incoming data&#34;&#34;&#34;

        self.destination_address = args.destination_address
        &#34;&#34;&#34;IP address used to send data&#34;&#34;&#34;

        self.destination_port = args.destination_port
        &#34;&#34;&#34;Port used to send data&#34;&#34;&#34;

        self.sample_type = np.int16
        &#34;&#34;&#34;Typo of sample. Used for data definition and size calculation&#34;&#34;&#34;

        self.samples_per_chunk = self.chunk_size * self.number_of_channels
        &#34;&#34;&#34;Number of audio samples required per chunk.&#34;&#34;&#34;

        self.bytes_per_chunk = self.samples_per_chunk * np.dtype(self.sample_type).itemsize
        &#34;&#34;&#34;Size of audio chunk in bytes.&#34;&#34;&#34;

        # Assertion is activated if number of bytes per chunk is less than maximum payload size
        # This action is used to ensure reliable UDP communication
        assert self.bytes_per_chunk &lt;= MinimalIntercom.MAX_PAYLOAD_BYTES, \
        f&#34;bytes_per_chunk={self.bytes_per_chunk} &gt; MAX_PAYLOAD_BYTES={MinimalIntercom.MAX_PAYLOAD_BYTES}h&#34;

        # Endpoints pair declaration
        self.sender_endpoint = (self.destination_address, self.destination_port)
        &#34;&#34;&#34;Sender endpoint. Fixed to destination IP address and port&#34;&#34;&#34;

        self.receiver_endpoint = (&#34;0.0.0.0&#34;, self.source_port)
        &#34;&#34;&#34;Receiver endpoint. Fixed to any IP address and port used for listening&#34;&#34;&#34;

        # Socket initialization
        self.sender_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
        &#34;&#34;&#34;Sender socket. Used to send data.&#34;&#34;&#34;

        self.receiver_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
        &#34;&#34;&#34;Receiver socket. Binded to receiver endpoint. By default is set to 
        non blocking mode&#34;&#34;&#34;

        # Set receiver socket in non bloking
        self.receiver_socket.setblocking(0)
        self.receiver_socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 30000)

        # Bind listener socket
        self.receiver_socket.bind(self.receiver_endpoint)

        # Auxiliary chunk filled width zeros
        self.zero_chunk = self.generate_zero_chunk()

        # Data received via socket. Initialized with zero values
        self.data = self.generate_zero_chunk()
        &#34;&#34;&#34;Numpy array to store data received &#34;&#34;&#34;

    # Destructor of class
    def __del__(self):
        &#34;&#34;&#34; Destructor of class. Just closes socket before to destroy it &#34;&#34;&#34;
        self.receiver_socket.close()

    def to_print(self):
        &#34;&#34;&#34;To print instance main variables. Used to know current instance&#39;s status&#34;&#34;&#34;

        print(f&#34;Minimal intercom: number_of_channels={self.number_of_channels}&#34;)
        print(f&#34;Minimal intercom: sample rate={self.sample_rate}&#34;)
        print(f&#34;Minimal intercom: chunk_size={self.chunk_size}&#34;)
        print(f&#34;Minimal intercom: samples_per_chunk={self.samples_per_chunk}&#34;)
        print(f&#34;Minimal intercom: source port={self.source_port}&#34;)
        print(f&#34;Minimal intercom: destination_address={self.destination_address}&#34;)
        print(f&#34;Minimal intercom: destination_port={self.destination_port}&#34;)
        print(f&#34;Minimal intercom: bytes_per_chunk={self.bytes_per_chunk}&#34;)

    # Zero chunk generator
    def generate_zero_chunk(self):
        &#34;&#34;&#34; Generator of numpy chunk filled with zeros

        Returns
        ------
            numpy array filled with zeros
        &#34;&#34;&#34;
        return np.zeros((self.chunk_size, self.number_of_channels), self.sample_type)

    def send(self, data):
        &#34;&#34;&#34; Send data over sender socket

        Parameters
        ----------
        data
            Data to send over UDP socket. A numpy array is expected
        &#34;&#34;&#34;
        self.sender_socket.sendto(data, self.sender_endpoint)  #self.sender_endpoint)

    def receive(self):
        &#34;&#34;&#34;Receive data from receiver socket

        Raises
        ------
            Errno 11
                Resource temporarily unavailable. Socket may be empty.
                In non-blocking UDP socket an exception of this type is raised.

        Returns
        -------
            Numpy array of FIFO socket buffer
        &#34;&#34;&#34;

        # Data is required from socket. However, socket may have no data, so to handle
        # this situation, try-catch block is required
        try:
            # Store received data in local variable
            data, status = self.receiver_socket.recvfrom(self.bytes_per_chunk)

            # Due to data is byte object, conversion to numpy array is required
            data = np.frombuffer(data, self.sample_type).reshape(self.chunk_size, self.number_of_channels)
        except Exception as e:
            print(&#34;Exception: &#34;, e)
            # Id there is no data in socket, get zero filled chunk
            data = self.generate_zero_chunk()

        # Return data
        return data

    def feedback(self):
        &#34;&#34;&#34;Calculates process parameters&#34;&#34;&#34;
        global CPU_total
        global CPU_samples
        CPU_usage = psutil.cpu_percent()  # User (not intercom) time
        CPU_total += CPU_usage
        CPU_samples += 1
        print(f&#34;{int(CPU_usage)}&#34;, flush=True, end=&#39; &#39;)

    # Callback method required from non blocking Sounddevice audio stream
    def callback(self, indata, outdata, frames, time, status):
        &#34;&#34;&#34;Callback method

        In non blocking audio stream, a new thread is created
        and periodically executes the callback method. Usually
        the call occurs when new input data (indata) is available to
        manipulate. Is recommended to manage output stream in the callback
        method also

        Note: This method has the implementation of the algorithm
        proposed in milestone 5 in Multimedia Technology subject

        The arguments are imposed to Sounndevice callback signature
        &#34;&#34;&#34;

        # Send data via sender socket
        self.send(indata)

        # Receive and store data to play
        outdata[:] = self.receive()

        # Print current process status
        self.feedback()

    def start(self):
        &#34;&#34;&#34;Starts sounddevice audio stream via callbacks method&#34;&#34;&#34;
        with sd.Stream(samplerate=self.sample_rate, blocksize=self.chunk_size, dtype=self.sample_type,
                       channels=self.number_of_channels, callback=self.callback):
            input()

    @staticmethod
    def add_args():
        &#34;&#34;&#34;Allows to parse command line arguments. Default values (class attributes)
            are used by any parameter not provided

            Returns
            -------
                Parser structure with parameters to initialize MinimalIntercom instance
        &#34;&#34;&#34;
        parser = argparse.ArgumentParser(description = &#34;Real-Time Audio Intercommunicator&#34;,
                                        formatter_class = argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument(&#34;-s&#34;, &#34;--frames_per_chunk&#34;,
                            help=&#34;Number of frames (stereo samples) per chunk.&#34;,
                            type=int, default=MinimalIntercom.CHUNK_SIZE)
        parser.add_argument(&#34;-r&#34;, &#34;--frames_per_second&#34;,
                            help=&#34;Sampling rate in frames/second.&#34;,
                            type=int, default=MinimalIntercom.SAMPLE_RATE)
        parser.add_argument(&#34;-c&#34;, &#34;--number_of_channels&#34;,
                            help=&#34;Number of channels.&#34;,
                            type=int, default=MinimalIntercom.NUMBER_CHANNELS)
        parser.add_argument(&#34;-p&#34;, &#34;--source_port&#34;,
                            help=&#34;My listening port.&#34;,
                            type=int, default=MinimalIntercom.SOURCE_PORT)
        parser.add_argument(&#34;-i&#34;, &#34;--destination_port&#34;,
                            help=&#34;Interlocutor&#39;s listening port.&#34;,
                            type=int, default=MinimalIntercom.DESTINATION_PORT)
        parser.add_argument(&#34;-a&#34;, &#34;--destination_address&#34;,
                            help=&#34;Interlocutor&#39;s IP address or name.&#34;,
                            type=str, default=MinimalIntercom.DESTINATION_ADDRESS)
        return parser</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="minimal-intercom.MinimalIntercom.CHUNK_SIZE"><code class="name">var <span class="ident">CHUNK_SIZE</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Size of sampling chunk. A chunk is composed
by frames</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.DESTINATION_ADDRESS"><code class="name">var <span class="ident">DESTINATION_ADDRESS</span></code></dt>
<dd>
<div class="desc"><p>(string) (static): IP address of destination computer</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.DESTINATION_PORT"><code class="name">var <span class="ident">DESTINATION_PORT</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Port used to send data to networks</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.MAX_PAYLOAD_BYTES"><code class="name">var <span class="ident">MAX_PAYLOAD_BYTES</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Maximum size of UDP payload</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.NUMBER_CHANNELS"><code class="name">var <span class="ident">NUMBER_CHANNELS</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Number of channels by default</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.SAMPLE_RATE"><code class="name">var <span class="ident">SAMPLE_RATE</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Sampling frequency. Number of frames per second</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.SOURCE_PORT"><code class="name">var <span class="ident">SOURCE_PORT</span></code></dt>
<dd>
<div class="desc"><p>(int) (static): Port used to receive data from network</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="minimal-intercom.MinimalIntercom.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows to parse command line arguments. Default values (class attributes)
are used by any parameter not provided</p>
<h2 id="returns">Returns</h2>
<pre><code>Parser structure with parameters to initialize MinimalIntercom instance
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_args():
    &#34;&#34;&#34;Allows to parse command line arguments. Default values (class attributes)
        are used by any parameter not provided

        Returns
        -------
            Parser structure with parameters to initialize MinimalIntercom instance
    &#34;&#34;&#34;
    parser = argparse.ArgumentParser(description = &#34;Real-Time Audio Intercommunicator&#34;,
                                    formatter_class = argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(&#34;-s&#34;, &#34;--frames_per_chunk&#34;,
                        help=&#34;Number of frames (stereo samples) per chunk.&#34;,
                        type=int, default=MinimalIntercom.CHUNK_SIZE)
    parser.add_argument(&#34;-r&#34;, &#34;--frames_per_second&#34;,
                        help=&#34;Sampling rate in frames/second.&#34;,
                        type=int, default=MinimalIntercom.SAMPLE_RATE)
    parser.add_argument(&#34;-c&#34;, &#34;--number_of_channels&#34;,
                        help=&#34;Number of channels.&#34;,
                        type=int, default=MinimalIntercom.NUMBER_CHANNELS)
    parser.add_argument(&#34;-p&#34;, &#34;--source_port&#34;,
                        help=&#34;My listening port.&#34;,
                        type=int, default=MinimalIntercom.SOURCE_PORT)
    parser.add_argument(&#34;-i&#34;, &#34;--destination_port&#34;,
                        help=&#34;Interlocutor&#39;s listening port.&#34;,
                        type=int, default=MinimalIntercom.DESTINATION_PORT)
    parser.add_argument(&#34;-a&#34;, &#34;--destination_address&#34;,
                        help=&#34;Interlocutor&#39;s IP address or name.&#34;,
                        type=str, default=MinimalIntercom.DESTINATION_ADDRESS)
    return parser</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="minimal-intercom.MinimalIntercom.bytes_per_chunk"><code class="name">var <span class="ident">bytes_per_chunk</span></code></dt>
<dd>
<div class="desc"><p>Size of audio chunk in bytes.</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.chunk_size"><code class="name">var <span class="ident">chunk_size</span></code></dt>
<dd>
<div class="desc"><p>Size of sampling chunk.</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Numpy array to store data received</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.destination_address"><code class="name">var <span class="ident">destination_address</span></code></dt>
<dd>
<div class="desc"><p>IP address used to send data</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.destination_port"><code class="name">var <span class="ident">destination_port</span></code></dt>
<dd>
<div class="desc"><p>Port used to send data</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.number_of_channels"><code class="name">var <span class="ident">number_of_channels</span></code></dt>
<dd>
<div class="desc"><p>number_of_channels (int): Number of channels</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.receiver_endpoint"><code class="name">var <span class="ident">receiver_endpoint</span></code></dt>
<dd>
<div class="desc"><p>Receiver endpoint. Fixed to any IP address and port used for listening</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.receiver_socket"><code class="name">var <span class="ident">receiver_socket</span></code></dt>
<dd>
<div class="desc"><p>Receiver socket. Binded to receiver endpoint. By default is set to
non blocking mode</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.sample_rate"><code class="name">var <span class="ident">sample_rate</span></code></dt>
<dd>
<div class="desc"><p>Sampling frequency. Number of frames per second</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.sample_type"><code class="name">var <span class="ident">sample_type</span></code></dt>
<dd>
<div class="desc"><p>Typo of sample. Used for data definition and size calculation</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.samples_per_chunk"><code class="name">var <span class="ident">samples_per_chunk</span></code></dt>
<dd>
<div class="desc"><p>Number of audio samples required per chunk.</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.sender_endpoint"><code class="name">var <span class="ident">sender_endpoint</span></code></dt>
<dd>
<div class="desc"><p>Sender endpoint. Fixed to destination IP address and port</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.sender_socket"><code class="name">var <span class="ident">sender_socket</span></code></dt>
<dd>
<div class="desc"><p>Sender socket. Used to send data.</p></div>
</dd>
<dt id="minimal-intercom.MinimalIntercom.source_port"><code class="name">var <span class="ident">source_port</span></code></dt>
<dd>
<div class="desc"><p>Port used to listen incoming data</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="minimal-intercom.MinimalIntercom.callback"><code class="name flex">
<span>def <span class="ident">callback</span></span>(<span>self, indata, outdata, frames, time, status)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback method</p>
<p>In non blocking audio stream, a new thread is created
and periodically executes the callback method. Usually
the call occurs when new input data (indata) is available to
manipulate. Is recommended to manage output stream in the callback
method also</p>
<p>Note: This method has the implementation of the algorithm
proposed in milestone 5 in Multimedia Technology subject</p>
<p>The arguments are imposed to Sounndevice callback signature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callback(self, indata, outdata, frames, time, status):
    &#34;&#34;&#34;Callback method

    In non blocking audio stream, a new thread is created
    and periodically executes the callback method. Usually
    the call occurs when new input data (indata) is available to
    manipulate. Is recommended to manage output stream in the callback
    method also

    Note: This method has the implementation of the algorithm
    proposed in milestone 5 in Multimedia Technology subject

    The arguments are imposed to Sounndevice callback signature
    &#34;&#34;&#34;

    # Send data via sender socket
    self.send(indata)

    # Receive and store data to play
    outdata[:] = self.receive()

    # Print current process status
    self.feedback()</code></pre>
</details>
</dd>
<dt id="minimal-intercom.MinimalIntercom.feedback"><code class="name flex">
<span>def <span class="ident">feedback</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates process parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def feedback(self):
    &#34;&#34;&#34;Calculates process parameters&#34;&#34;&#34;
    global CPU_total
    global CPU_samples
    CPU_usage = psutil.cpu_percent()  # User (not intercom) time
    CPU_total += CPU_usage
    CPU_samples += 1
    print(f&#34;{int(CPU_usage)}&#34;, flush=True, end=&#39; &#39;)</code></pre>
</details>
</dd>
<dt id="minimal-intercom.MinimalIntercom.generate_zero_chunk"><code class="name flex">
<span>def <span class="ident">generate_zero_chunk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator of numpy chunk filled with zeros</p>
<h2 id="returns">Returns</h2>
<pre><code>numpy array filled with zeros
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_zero_chunk(self):
    &#34;&#34;&#34; Generator of numpy chunk filled with zeros

    Returns
    ------
        numpy array filled with zeros
    &#34;&#34;&#34;
    return np.zeros((self.chunk_size, self.number_of_channels), self.sample_type)</code></pre>
</details>
</dd>
<dt id="minimal-intercom.MinimalIntercom.receive"><code class="name flex">
<span>def <span class="ident">receive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive data from receiver socket</p>
<h2 id="raises">Raises</h2>
<pre><code>Errno 11
    Resource temporarily unavailable. Socket may be empty.
    In non-blocking UDP socket an exception of this type is raised.
</code></pre>
<h2 id="returns">Returns</h2>
<pre><code>Numpy array of FIFO socket buffer
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive(self):
    &#34;&#34;&#34;Receive data from receiver socket

    Raises
    ------
        Errno 11
            Resource temporarily unavailable. Socket may be empty.
            In non-blocking UDP socket an exception of this type is raised.

    Returns
    -------
        Numpy array of FIFO socket buffer
    &#34;&#34;&#34;

    # Data is required from socket. However, socket may have no data, so to handle
    # this situation, try-catch block is required
    try:
        # Store received data in local variable
        data, status = self.receiver_socket.recvfrom(self.bytes_per_chunk)

        # Due to data is byte object, conversion to numpy array is required
        data = np.frombuffer(data, self.sample_type).reshape(self.chunk_size, self.number_of_channels)
    except Exception as e:
        print(&#34;Exception: &#34;, e)
        # Id there is no data in socket, get zero filled chunk
        data = self.generate_zero_chunk()

    # Return data
    return data</code></pre>
</details>
</dd>
<dt id="minimal-intercom.MinimalIntercom.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Send data over sender socket</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>Data to send over UDP socket. A numpy array is expected</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, data):
    &#34;&#34;&#34; Send data over sender socket

    Parameters
    ----------
    data
        Data to send over UDP socket. A numpy array is expected
    &#34;&#34;&#34;
    self.sender_socket.sendto(data, self.sender_endpoint)  #self.sender_endpoint)</code></pre>
</details>
</dd>
<dt id="minimal-intercom.MinimalIntercom.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts sounddevice audio stream via callbacks method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;Starts sounddevice audio stream via callbacks method&#34;&#34;&#34;
    with sd.Stream(samplerate=self.sample_rate, blocksize=self.chunk_size, dtype=self.sample_type,
                   channels=self.number_of_channels, callback=self.callback):
        input()</code></pre>
</details>
</dd>
<dt id="minimal-intercom.MinimalIntercom.to_print"><code class="name flex">
<span>def <span class="ident">to_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>To print instance main variables. Used to know current instance's status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_print(self):
    &#34;&#34;&#34;To print instance main variables. Used to know current instance&#39;s status&#34;&#34;&#34;

    print(f&#34;Minimal intercom: number_of_channels={self.number_of_channels}&#34;)
    print(f&#34;Minimal intercom: sample rate={self.sample_rate}&#34;)
    print(f&#34;Minimal intercom: chunk_size={self.chunk_size}&#34;)
    print(f&#34;Minimal intercom: samples_per_chunk={self.samples_per_chunk}&#34;)
    print(f&#34;Minimal intercom: source port={self.source_port}&#34;)
    print(f&#34;Minimal intercom: destination_address={self.destination_address}&#34;)
    print(f&#34;Minimal intercom: destination_port={self.destination_port}&#34;)
    print(f&#34;Minimal intercom: bytes_per_chunk={self.bytes_per_chunk}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="minimal-intercom.MinimalIntercom" href="#minimal-intercom.MinimalIntercom">MinimalIntercom</a></code></h4>
<ul class="two-column">
<li><code><a title="minimal-intercom.MinimalIntercom.CHUNK_SIZE" href="#minimal-intercom.MinimalIntercom.CHUNK_SIZE">CHUNK_SIZE</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.DESTINATION_ADDRESS" href="#minimal-intercom.MinimalIntercom.DESTINATION_ADDRESS">DESTINATION_ADDRESS</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.DESTINATION_PORT" href="#minimal-intercom.MinimalIntercom.DESTINATION_PORT">DESTINATION_PORT</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.MAX_PAYLOAD_BYTES" href="#minimal-intercom.MinimalIntercom.MAX_PAYLOAD_BYTES">MAX_PAYLOAD_BYTES</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.NUMBER_CHANNELS" href="#minimal-intercom.MinimalIntercom.NUMBER_CHANNELS">NUMBER_CHANNELS</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.SAMPLE_RATE" href="#minimal-intercom.MinimalIntercom.SAMPLE_RATE">SAMPLE_RATE</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.SOURCE_PORT" href="#minimal-intercom.MinimalIntercom.SOURCE_PORT">SOURCE_PORT</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.add_args" href="#minimal-intercom.MinimalIntercom.add_args">add_args</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.bytes_per_chunk" href="#minimal-intercom.MinimalIntercom.bytes_per_chunk">bytes_per_chunk</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.callback" href="#minimal-intercom.MinimalIntercom.callback">callback</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.chunk_size" href="#minimal-intercom.MinimalIntercom.chunk_size">chunk_size</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.data" href="#minimal-intercom.MinimalIntercom.data">data</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.destination_address" href="#minimal-intercom.MinimalIntercom.destination_address">destination_address</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.destination_port" href="#minimal-intercom.MinimalIntercom.destination_port">destination_port</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.feedback" href="#minimal-intercom.MinimalIntercom.feedback">feedback</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.generate_zero_chunk" href="#minimal-intercom.MinimalIntercom.generate_zero_chunk">generate_zero_chunk</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.number_of_channels" href="#minimal-intercom.MinimalIntercom.number_of_channels">number_of_channels</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.receive" href="#minimal-intercom.MinimalIntercom.receive">receive</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.receiver_endpoint" href="#minimal-intercom.MinimalIntercom.receiver_endpoint">receiver_endpoint</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.receiver_socket" href="#minimal-intercom.MinimalIntercom.receiver_socket">receiver_socket</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.sample_rate" href="#minimal-intercom.MinimalIntercom.sample_rate">sample_rate</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.sample_type" href="#minimal-intercom.MinimalIntercom.sample_type">sample_type</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.samples_per_chunk" href="#minimal-intercom.MinimalIntercom.samples_per_chunk">samples_per_chunk</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.send" href="#minimal-intercom.MinimalIntercom.send">send</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.sender_endpoint" href="#minimal-intercom.MinimalIntercom.sender_endpoint">sender_endpoint</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.sender_socket" href="#minimal-intercom.MinimalIntercom.sender_socket">sender_socket</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.source_port" href="#minimal-intercom.MinimalIntercom.source_port">source_port</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.start" href="#minimal-intercom.MinimalIntercom.start">start</a></code></li>
<li><code><a title="minimal-intercom.MinimalIntercom.to_print" href="#minimal-intercom.MinimalIntercom.to_print">to_print</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>